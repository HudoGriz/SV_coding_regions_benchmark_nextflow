/*
========================================================================================
    Nextflow Configuration File
========================================================================================
*/

// Global default params
params {
    // Pipeline run name
    run_name = 'benchmarking_run'
    
    // Output directory
    outdir = "${launchDir}/${run_name}"
    
    // Reference files
    fasta = null
    
    // Input BAM files (optional - set as needed)
    illumina_wes_bam = null
    illumina_wgs_bam = null
    pacbio_bam = null
    ont_bam = null
    
    // Benchmarking files
    benchmark_vcf = null
    high_confidence_targets = null
    gene_panel_targets = null
    wes_utr_targets = null
    
    // Optional files
    tandem_repeats = null
    
    // Truvari parameters
    truvari_refdist = 500
    truvari_pctsize = 0.7
    truvari_pctovl = 0
    truvari_pctseq = 0
    
    // WES-specific Truvari parameters (if different)
    truvari_wes_refdist = 500
    truvari_wes_pctsize = 0.7
    truvari_wes_pctovl = 0
    truvari_wes_pctseq = 0
    
    // Resource defaults
    max_cpus = 24
    max_memory = '128.GB'
    max_time = '48.h'
    
    // GIAB resource preparation
    prepare_giab_resources = false
    prepare_complete_data = false
    genome = 'hs37d5'  // or 'GRCh38'
    project_dir = "${projectDir}"
    r_container = "${projectDir}/singularity_images/r-env_4-4-1.sif"
    
    // Skip flags for preparation workflows
    skip_singularity_download = false
    skip_bam_download = false
    skip_reference_download = false
    download_grch37_liftover = true
    
    // Optional gene panel BED files
    paediatric_disorders_bed = null
    paediatric_disorders_bed_grch38 = null
    
    // Control nf-core module publishing
    publish_gunzip = true
    publish_faidx = true
    
    // References directory
    references_dir = "${projectDir}/data/references"
    
    // Singularity container paths
    singularity_image_dir = "${projectDir}/singularity_images"
    container_manta = "file://${singularity_image_dir}/manta_latest.sif"
    container_cutesv = "file://${singularity_image_dir}/cutesv_latest.sif"
    container_pbsv = "file://${singularity_image_dir}/pbsv_latest.sif"
    container_sniffles = "file://${singularity_image_dir}/sniffles_latest.sif"
    container_samtools = "file://${singularity_image_dir}/samtools_latest.sif"
    container_truvari = "file://${singularity_image_dir}/truvari_modded.sif"
    
    // Help message
    help = false
}

// Process configuration
process {
    // Default resources
    cpus = 1
    memory = 4.GB
    time = 4.h
    
    // Error strategy
    errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'finish' }
    maxRetries = 2
    maxErrors = '-1'
    
    // Process-specific resources (nf-core modules use their own containers)
    withName: 'MANTA_GERMLINE' {
        cpus = { check_max(8, 'cpus') }
        memory = { check_max(32.GB, 'memory') }
        time = { check_max(12.h, 'time') }
        publishDir = [
            path: { "${params.outdir}/calls/${task.ext.technology ?: 'unknown'}/sv/manta" },
            mode: 'copy',
            pattern: '*.{vcf.gz,vcf.gz.tbi}'
        ]
    }
    
    withName: 'CUTESV_.*' {
        cpus = { check_max(params.max_cpus, 'cpus') }
        memory = { check_max(64.GB, 'memory') }
        time = { check_max(8.h, 'time') }
    }
    
    withName: 'PBSV_DISCOVER' {
        cpus = 1
        memory = { check_max(8.GB, 'memory') }
        time = { check_max(4.h, 'time') }
    }
    
    withName: 'PBSV_CALL' {
        cpus = { check_max(params.max_cpus, 'cpus') }
        memory = { check_max(32.GB, 'memory') }
        time = { check_max(8.h, 'time') }
    }
    
    withName: 'SNIFFLES' {
        cpus = { check_max(params.max_cpus, 'cpus') }
        memory = { check_max(32.GB, 'memory') }
        time = { check_max(8.h, 'time') }
        publishDir = [
            path: { "${params.outdir}/calls/${task.ext.technology ?: 'unknown'}/sv/sniffles" },
            mode: 'copy',
            pattern: '*.{vcf.gz,vcf.gz.tbi}'
        ]
    }
    
    withName: 'BGZIP_TABIX.*' {
        cpus = 2
        memory = 4.GB
        time = 2.h
        publishDir = [
            path: { "${params.outdir}/calls/${task.ext.technology ?: 'unknown'}/sv/${task.ext.tool_lc ?: 'unknown'}" },
            mode: 'copy',
            pattern: '*.{vcf.gz,vcf.gz.tbi}'
        ]
    }
    
    withName: 'TRUVARI_BENCH' {
        container = params.container_truvari
        cpus = 2
        memory = { check_max(16.GB, 'memory') }
        time = { check_max(4.h, 'time') }
    }
    
    withName: 'DOWNLOAD_.*' {
        cpus = 1
        memory = 2.GB
        time = 2.h
        errorStrategy = 'retry'
        maxRetries = 3
    }
    
    withName: 'CREATE_EXOME_UTR_BED' {
        cpus = 1
        memory = 8.GB
        time = 1.h
    }
    
    withName: 'SAMTOOLS_FAIDX' {
        container = params.container_samtools
        cpus = 1
        memory = 2.GB
        time = 1.h
    }
    
    withName: 'TABIX_VCF' {
        container = params.container_samtools
        cpus = 1
        memory = 2.GB
        time = 30.m
    }
    
    withName: 'BEDTOOLS_INTERSECT|INTERSECT_.*' {
        cpus = 1
        memory = 4.GB
        time = 1.h
        ext.suffix = 'bed'
        publishDir = [
            path: { "${params.references_dir}" },
            mode: 'copy',
            enabled: true
        ]
    }
    
    withName: 'GUNZIP' {
        cpus = 1
        memory = 2.GB
        time = 1.h
        publishDir = [
            path: { "${params.references_dir}" },
            mode: 'copy',
            enabled: params.publish_gunzip
        ]
    }
    
    withName: 'SAMTOOLS_FAIDX' {
        cpus = 1
        memory = 2.GB
        time = 1.h
        publishDir = [
            path: { "${params.references_dir}" },
            mode: 'copy',
            enabled: params.publish_faidx
        ]
    }
}

// Execution profiles
profiles {
    // Base configuration
    base {
        includeConfig 'conf/base.config'
    }
    
    // Test profiles
    test {
        includeConfig 'conf/test.config'
    }
    
    test_nfcore {
        includeConfig 'conf/test_nfcore.config'
    }
    
    singularity {
        singularity.enabled = true
        singularity.autoMounts = true
        singularity.runOptions = '--cleanenv'
    }
    
    docker {
        docker.enabled = true
        docker.runOptions = '-u $(id -u):$(id -g)'
    }
    
    local {
        process.executor = 'local'
    }
    
    slurm {
        process.executor = 'slurm'
        process.queue = 'normal'
    }
    
    standard {
        singularity.enabled = true
        singularity.autoMounts = true
        process.executor = 'local'
    }
    
    giab_grch37 {
        params.prepare_giab_resources = true
        params.genome = 'hs37d5'
        singularity.enabled = true
        singularity.autoMounts = true
        process.executor = 'local'
    }
    
    giab_grch38 {
        params.prepare_giab_resources = true
        params.genome = 'GRCh38'
        singularity.enabled = true
        singularity.autoMounts = true
        process.executor = 'local'
    }
    
    complete_grch37 {
        params.prepare_complete_data = true
        params.genome = 'hs37d5'
        params.skip_singularity_download = false
        params.skip_bam_download = false
        params.skip_reference_download = false
        singularity.enabled = true
        singularity.autoMounts = true
        process.executor = 'local'
    }
    
    complete_grch38 {
        params.prepare_complete_data = true
        params.genome = 'GRCh38'
        params.skip_bam_download = false
        params.skip_reference_download = false
        params.download_grch37_liftover = true
        singularity.enabled = true
        singularity.autoMounts = true
        process.executor = 'local'
    }
}

// Manifest
manifest {
    name = 'sv-calling-pipeline'
    author = 'Your Name'
    description = 'Structural variant calling and benchmarking pipeline for multiple sequencing technologies'
    mainScript = 'main.nf'
    nextflowVersion = '>=23.04.0'
    version = '1.0.0'
}

// Function to ensure that resource requirements don't go beyond maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min(obj, params.max_cpus as int)
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}

// Capture exit codes from upstream processes when piping
process.shell = ['/bin/bash', '-euo', 'pipefail']

// Trace and timeline reports
timeline {
    enabled = true
    file = "${params.outdir}/pipeline_info/execution_timeline.html"
}

report {
    enabled = true
    file = "${params.outdir}/pipeline_info/execution_report.html"
}

trace {
    enabled = true
    file = "${params.outdir}/pipeline_info/execution_trace.txt"
}

dag {
    enabled = true
    file = "${params.outdir}/pipeline_info/pipeline_dag.svg"
}
